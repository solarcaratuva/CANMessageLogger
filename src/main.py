import argparse
from backend.functions import gitPull
import time
import os
from backend import config
def setup_socketio():
    from backend.sockio.socket import socketio, app
    from backend.sockio import debug  # must be imported to register the socketio event handlers
    from backend.db_connection import DbConnection
    from backend.input import consumer, logfile_producer, monitor_live_log
    from functools import partial
    return socketio, app, debug, DbConnection, consumer, logfile_producer, monitor_live_log, partial

def main():
    timestamp = time.strftime("%Y%m%d_%H%M%S")

    newpath = './CANDatabases' 
    if not os.path.exists(newpath):
        os.makedirs(newpath)
    # timestamp: year,month,day,hour,minute,second
    database_path = f"./CANDatabases/can_database_{timestamp}.sqlite"

    datafile_path = None

    parser = cli_message_reader()
    args = parser.parse_args()

    can_messages_config = config.REPO_CONFIG["submodules"]["CAN-messages"]
    submodule_path = os.path.relpath(can_messages_config["path"])

    success, message = gitPull(args.set_dbc_branch, submodule_path=submodule_path)
    print("[GIT]", message)
    if not success:
        print("[GIT ERROR] Continuing anyway...")

    socketio, app, debug, DbConnection, consumer, logfile_producer, monitor_live_log, partial = setup_socketio()

    if args.inputFile:
        datafile_path = args.inputFile[0]

    if args.outputDB:
        database_path = args.outputDB[0]

    if args.logType == "db":
        if not args.inputFile:
            parser.error("The '--inputFile' option is required when 'db' is provided.")
        if not (args.inputFile[0].endswith(".db")) and not (args.inputFile[0].endswith(".sqlite")):
            parser.error("Need to specify a .db or .sqlite file")

            database_path = args.inputFile[0]

    # need to call .set_up_tables and .setup_database_path here!! (before running threads)
    DbConnection.setup_the_db_path(database_path)

    dbconn = DbConnection()
    dbconn.setup_the_tables()

    match args.logType:
        case "past_log":
            if not args.inputFile:
                parser.error("The '--inputFile' option is required when 'past_log' is provided.")
            if not args.inputFile[0].endswith(".txt"):
                parser.error("Need to specify a .txt file")

            logfile_producer.process_logfile(datafile_path)
            consumer.process_data()

        case "livelog":
            socketio.start_background_task(target=consumer.process_data_live)
            socketio.start_background_task(target=monitor_live_log.listen_to_serial)

        case "mock_livelog":
            if not args.inputFile:
                parser.error("The '--inputFile' option is required when 'mock_livelog' is provided.")
            if not args.inputFile[0].endswith(".txt"):
                parser.error("Need to specify a .txt file")

            socketio.start_background_task(target=consumer.process_data_live)
            socketio.start_background_task(target=partial(logfile_producer.process_logfile_live, datafile_path))
        

    socketio.run(app, debug=False, allow_unsafe_werkzeug=True)  # to run the sockio io app, .run is blocking! No code below this


def cli_message_reader() -> argparse.ArgumentParser:
    """Creates the command line arguments parser for the main function"""

    datatype_choices =["past_log", "livelog", "mock_livelog", "db"]

    parser = argparse.ArgumentParser() 
    parser.add_argument("logType", choices=datatype_choices, type=str,
                        help=f"The type of database connection you wish to establish. Input must be one of:"
                             f" {', '.join(datatype_choices)}")
    parser.add_argument("--inputFile", "-i", type=str, nargs=1,
                        help="specifies path of input file, must be followed by logfile path")
    parser.add_argument("--outputDB", "-o", type=str, nargs=1, default=None,
                        help="specifies the name of the output DB, name is autogenerated if not specified")
    parser.add_argument("--set_dbc_branch", type=str,
                       help="sets the branch of the DBC files submodule", default='main')

    return parser


if __name__ == "__main__":
    main()

