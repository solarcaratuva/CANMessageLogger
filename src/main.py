import argparse
import sys
from backend.submodule_automation import initialize_submodule, get_submodule_branches, set_submodule_branch, is_connected
import time
import os
import webbrowser

from backend.submodule_automation import gitPull
import backend.dbcs as dbcs
from backend.sockio.socket import socketio, app as socketio_app
from backend.db_connection import DbConnection
from backend.input import consumer, logfile_producer, live_log_producer, radio_producer
from functools import partial
from backend.sockio import debug_dashboard, alert_manager  # noqa: F401 (ensure handlers are registered)
from startup_server import launch_startup_options

from backend.sockio import debug_dashboard, alert_manager, graph_view 

def build_parser() -> argparse.ArgumentParser:
    data_sources = ["pastlog", "livelog", "mock_livelog", "db", "radio"]
    parser = argparse.ArgumentParser()
    parser.add_argument("logType", choices=data_sources, type=str.lower,
                        help="The type of data source to use.")
    parser.add_argument("--inputFile", "-i", type=str, nargs=1,
                        help="Path of input file (.log/.db) depending on mode.")
    parser.add_argument("--outputDB", "-o", type=str, nargs=1, default=None,
                        help="Output DB name (.db). Autogenerated if not specified.")
    parser.add_argument("--set_dbc_branch", "-b", type=str, default="main",
                        help="Branch of the DBC files submodule.")
    return parser

def run_server(args):
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    db_dir = './CANDatabases'
    if not os.path.exists(db_dir):
        os.makedirs(db_dir)

    # Initialize submodule at startup
    print("[STARTUP] Initializing submodule...")
    try:
        initialize_submodule()
        
        # Get available branches
        available_branches = get_submodule_branches()
        print(f"[STARTUP] Available DBC branches: {available_branches}")
        
        # Set the requested branch
        online = is_connected()
        print(f"[STARTUP] Internet connection: {'Available' if online else 'Not available'}")
        
        set_submodule_branch(args.set_dbc_branch, online)
        print(f"[STARTUP] Successfully set DBC branch to: {args.set_dbc_branch}")
        
        # Print detailed verification info
        print("[VERIFICATION] Checking DBC submodule status...")
        import git
        submodule_path = os.path.join("resources", "CAN-messages")
        if os.path.exists(submodule_path):
            repo = git.Repo(submodule_path)
            current_branch = repo.active_branch.name
            current_commit = repo.head.commit.hexsha[:8]
            commit_message = repo.head.commit.message.strip()
            commit_date = repo.head.commit.committed_datetime.strftime("%Y-%m-%d %H:%M:%S")
            
            print(f"[VERIFICATION] Current branch: {current_branch}")
            print(f"[VERIFICATION] Current commit: {current_commit}")
            print(f"[VERIFICATION] Commit message: {commit_message}")
            print(f"[VERIFICATION] Commit date: {commit_date}")
            
            # List DBC files in the submodule
            dbc_files = [f for f in os.listdir(submodule_path) if f.endswith('.dbc')]
            print(f"[VERIFICATION] DBC files found: {dbc_files}")
        else:
            print("[VERIFICATION] Submodule directory not found!")
        
    except Exception as e:
        print(f"[STARTUP ERROR] Submodule setup failed: {e}")
        print("[STARTUP ERROR] Continuing anyway...")

    dbcs.load_dbc_files()

    if args.inputFile and not os.path.exists(args.inputFile[0]):
        print(f"The input file '{args.inputFile[0]}' does not exist.")
        sys.exit()

    datafile_path = args.inputFile[0] if args.inputFile else None

    database_path = f"./CANDatabases/can_database_{timestamp}.db"
    if args.outputDB:
        database_path = args.outputDB[0]
    if not database_path.endswith(".db"):
        print("Need to specify a .db file for the output database")
        sys.exit()

    if args.logType == "db":
        if not args.inputFile:
            print("The '--inputFile' option is required when 'db' is provided.")
            sys.exit()
        if not (args.inputFile[0].endswith(".db")):
            print("Need to specify a .db file")
            sys.exit()
        database_path = args.inputFile[0]

    DbConnection.setup_the_db_path(database_path)
    dbconn = DbConnection()
    dbconn.setup_the_tables()

    if args.logType == "pastlog":
        if not args.inputFile or not (args.inputFile[0].endswith(".txt") or args.inputFile[0].endswith(".log")):
            print("For 'pastlog', need a .txt or .log file as --inputFile")
            sys.exit()
        logfile_producer.process_logfile(datafile_path)
        consumer.process_data()

    elif args.logType == "livelog":
        socketio.start_background_task(target=consumer.process_data_live)
        socketio.start_background_task(target=live_log_producer.listen_to_serial)

    elif args.logType == "mock_livelog":
        if not args.inputFile or not (args.inputFile[0].endswith(".txt") or args.inputFile[0].endswith(".log")):
            print("For 'mock_livelog', need a .txt or .log file as --inputFile")
            sys.exit()
        socketio.start_background_task(target=consumer.process_data_live)
        socketio.start_background_task(target=partial(logfile_producer.process_logfile_live, datafile_path))

    elif args.logType == "radio":
        socketio.start_background_task(target=consumer.process_data_live)
        socketio.start_background_task(target=radio_producer.listen_to_radio)

    print(f"Starting socketio server, \033[1;31mopen localhost:{SOCKETIO_PORT} in your browser\033[0m")
    webbrowser.open(f'http://localhost:{SOCKETIO_PORT}')
    socketio.run(socketio_app, debug=False, allow_unsafe_werkzeug=True, host="0.0.0.0", port=SOCKETIO_PORT)

def main():
    # Continue supporting CLI args 
    if len(sys.argv) > 1:
        parser = build_parser()
        args = parser.parse_args()
        run_server(args)
    else:
        # Only launches setup if no CLI args are shown
        launch_startup_options(run_server, SOCKETIO_PORT)

if __name__ == "__main__":
    main()
