import argparse
import sys
from backend.submodule_automation import initialize_submodule, get_submodule_branches, set_submodule_branch, is_connected
import time
import os
import git
import webbrowser
import backend.dbcs as dbcs
from backend.sockio.socket import socketio, app as socketio_app
from backend.db_connection import DbConnection
from backend.input import consumer, logfile_producer, live_log_producer, radio_producer
from functools import partial
from backend.sockio import debug_dashboard, alert_manager  # noqa: F401 (ensure handlers are registered)
from startup_server import launch_startup_options
from backend.startup_validation import validate_startup_requirements

from backend.sockio import debug_dashboard, alert_manager, graph_view 

SOCKETIO_PORT = 5500

def build_parser() -> argparse.ArgumentParser:
    data_sources = ["pastlog", "livelog", "mock_livelog", "db", "radio"]
    parser = argparse.ArgumentParser()
    parser.add_argument("logType", choices=data_sources, type=str.lower,
                        help="The type of data source to use.")
    parser.add_argument("--inputFile", "-i", type=str, nargs=1,
                        help="Path of input file (.log/.db) depending on mode.")
    parser.add_argument("--outputDB", "-o", type=str, nargs=1, default=None,
                        help="Output DB name (.db). Autogenerated if not specified.")
    parser.add_argument("--set_dbc_branch", "-b", type=str, default="main",
                        help="Branch of the DBC files submodule.")
    return parser

def run_server(args):
    # Validate startup requirements early - this prevents wasted thread creation
    input_file_path = args.inputFile[0] if args.inputFile else None
    errors = validate_startup_requirements(args.logType, input_file_path) 
    if errors:
        print("ERROR: Validation failed:")
        for error in errors:
            print(f"  - {error}")
        print("\nPlease fix these issues and try again.")
        exit(1)
    
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    db_dir = './CANDatabases'
    if not os.path.exists(db_dir):
        os.makedirs(db_dir)

    # Initialize submodule at startup
    initialize_submodule()
    
    # Get available branches
    available_branches = get_submodule_branches()
    
    set_submodule_branch(args.set_dbc_branch)
    print(f"[STARTUP] Successfully set DBC branch to: {args.set_dbc_branch}")
    
    # Print detailed verification info
    submodule_path = os.path.join("resources", "CAN-messages")
    if os.path.exists(submodule_path):
        repo = git.Repo(submodule_path)
        current_branch = repo.active_branch.name
        current_commit = repo.head.commit.hexsha[:8]
        commit_message = repo.head.commit.message.strip()
        commit_date = repo.head.commit.committed_datetime.strftime("%Y-%m-%d %H:%M:%S")
        
        print(f"[VERIFICATION] Current branch: {current_branch}")
        print(f"[VERIFICATION] Current commit: {current_commit}")
        print(f"[VERIFICATION] Commit message: {commit_message}")
        print(f"[VERIFICATION] Commit date: {commit_date}")
        
        # List DBC files in the submodule
        dbc_files = [f for f in os.listdir(submodule_path) if f.endswith('.dbc')]
    else:
        print("[VERIFICATION] Submodule directory not found!")
        

    dbcs.load_dbc_files()

    datafile_path = args.inputFile[0] if args.inputFile else None

    database_path = f"./CANDatabases/can_database_{timestamp}.db"
    if args.outputDB:
        database_path = args.outputDB[0]
    if not database_path.endswith(".db"):
        print("[STARTUP] Error: Need to specify a .db file for the output database")
        sys.exit()

    if args.logType == "db":
        database_path = args.inputFile[0]

    DbConnection.setup_the_db_path(database_path)
    dbconn = DbConnection()
    dbconn.setup_the_tables()

    if args.logType == "pastlog":
        logfile_producer.process_logfile(datafile_path)
        consumer.process_data()

    elif args.logType == "livelog":
        socketio.start_background_task(target=consumer.process_data_live)
        socketio.start_background_task(target=live_log_producer.listen_to_serial)

    elif args.logType == "mock_livelog":
        socketio.start_background_task(target=consumer.process_data_live)
        socketio.start_background_task(target=partial(logfile_producer.process_logfile_live, datafile_path))

    elif args.logType == "radio":
        socketio.start_background_task(target=consumer.process_data_live)
        socketio.start_background_task(target=radio_producer.listen_to_radio)

    print(f"Starting socketio server on localhost:{SOCKETIO_PORT}")
    socketio.run(socketio_app, debug=False, allow_unsafe_werkzeug=True, host="0.0.0.0", port=SOCKETIO_PORT)

def main():
    # Continue supporting CLI args 
    if len(sys.argv) > 1:
        parser = build_parser()
        args = parser.parse_args()
        run_server(args)
    else:
        # Only launches setup if no CLI args are shown
        launch_startup_options(run_server, SOCKETIO_PORT)

if __name__ == "__main__":
    main()
