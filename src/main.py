import argparse
import sys
import threading
from flask import Flask, request, send_file, redirect
import webbrowser
import time
import os

from backend.submodule_automation import gitPull
import backend.dbcs as dbcs
from backend.sockio.socket import socketio, app as socketio_app
from backend.db_connection import DbConnection
from backend.input import consumer, logfile_producer, live_log_producer, radio_producer
from functools import partial
from backend.sockio import debug_dashboard, alert_manager  # noqa: F401 (ensure handlers are registered)

SETUP_PORT = 5499
SOCKETIO_PORT = 5500

def build_parser() -> argparse.ArgumentParser:
    data_sources = ["pastlog", "livelog", "mock_livelog", "db", "radio"]
    parser = argparse.ArgumentParser()
    parser.add_argument("logType", choices=data_sources, type=str.lower,
                        help="The type of data source to use.")
    parser.add_argument("--inputFile", "-i", type=str, nargs=1,
                        help="Path of input file (log/db) depending on mode.")
    parser.add_argument("--outputDB", "-o", type=str, nargs=1, default=None,
                        help="Output DB name (.db/.sqlite). Autogenerated if not specified.")
    parser.add_argument("--set_dbc_branch", "-b", type=str, default="main",
                        help="Branch of the DBC files submodule.")
    return parser

def run_server(args):
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    db_dir = './CANDatabases'
    if not os.path.exists(db_dir):
        os.makedirs(db_dir)

    submodule_path = os.path.relpath("resources/CAN-messages")
    success, message = gitPull(args.set_dbc_branch, submodule_path=submodule_path)
    print("[GIT]", message)
    if not success:
        print("[GIT ERROR] Continuing anyway...")

    dbcs.load_dbc_files()

    if getattr(args, "inputFile", None) and args.inputFile and not os.path.exists(args.inputFile[0]):
        raise FileNotFoundError(f"The input file '{args.inputFile[0]}' does not exist.")

    datafile_path = args.inputFile[0] if args.inputFile else None

    database_path = f"./CANDatabases/can_database_{timestamp}.sqlite"
    if args.outputDB:
        database_path = args.outputDB[0]
    if not database_path.endswith(".db") and not database_path.endswith(".sqlite"):
        raise ValueError("Need to specify a .db or .sqlite file for the output database")

    if args.logType == "db":
        if not args.inputFile:
            raise ValueError("The '--inputFile' option is required when 'db' is provided.")
        if not (args.inputFile[0].endswith(".db") or args.inputFile[0].endswith(".sqlite")):
            raise ValueError("Need to specify a .db or .sqlite file")
        database_path = args.inputFile[0]

    DbConnection.setup_the_db_path(database_path)
    dbconn = DbConnection()
    dbconn.setup_the_tables()

    if args.logType == "pastlog":
        if not args.inputFile or not (args.inputFile[0].endswith(".txt") or args.inputFile[0].endswith(".log")):
            raise ValueError("For 'pastlog', need a .txt or .log file as --inputFile")
        logfile_producer.process_logfile(datafile_path)
        consumer.process_data()

    elif args.logType == "livelog":
        socketio.start_background_task(target=consumer.process_data_live)
        socketio.start_background_task(target=live_log_producer.listen_to_serial)

    elif args.logType == "mock_livelog":
        if not args.inputFile or not (args.inputFile[0].endswith(".txt") or args.inputFile[0].endswith(".log")):
            raise ValueError("For 'mock_livelog', need a .txt or .log file as --inputFile")
        socketio.start_background_task(target=consumer.process_data_live)
        socketio.start_background_task(target=partial(logfile_producer.process_logfile_live, datafile_path))

    elif args.logType == "radio":
        socketio.start_background_task(target=consumer.process_data_live)
        socketio.start_background_task(target=radio_producer.listen_to_radio)

    print(f"Starting socketio server, \033[1;31mopen localhost:{SOCKETIO_PORT} in your browser\033[0m")
    webbrowser.open(f'http://localhost:{SOCKETIO_PORT}')
    socketio.run(socketio_app, debug=False, allow_unsafe_werkzeug=True, host="0.0.0.0", port=SOCKETIO_PORT)

def launch_startup_options():
    """A minimal local setup server that collects options then launches the real app."""
    setup_app = Flask(__name__)

    @setup_app.route("/", methods=["GET"])
    def index():
        return send_file("frontend/html/startup_options.html")

    def _shutdown(flask_request):
        func = flask_request.environ.get("werkzeug.server.shutdown")
        if func:
            func()

    @setup_app.route("/start", methods=["POST"])
    def start():
        # Gather form inputs into an argparse-like Namespace
        class Opts: pass
        opts = Opts()
        opts.logType = request.form.get("logType")
        inputFile = request.form.get("inputFile") or ""
        opts.inputFile = [inputFile] if inputFile.strip() else None
        outputDB = request.form.get("outputDB") or ""
        opts.outputDB = [outputDB] if outputDB.strip() else None
        opts.set_dbc_branch = request.form.get("set_dbc_branch") or "main"

        # Launch the real server in a new thread
        t = threading.Thread(target=lambda: run_server(opts), daemon=True)
        t.start()

        # Close the setup server and redirect to the real app
        threading.Timer(0.25, lambda: _shutdown(request)).start()
        return redirect(f"http://localhost:{SOCKETIO_PORT}", code=302)

    # Open browser to setup UI and run the startup options server 
    webbrowser.open(f"http://localhost:{SETUP_PORT}")
    setup_app.run(host="127.0.0.1", port=SETUP_PORT, debug=False)

def main():
    # Continue supporting CLI args 
    if len(sys.argv) > 1:
        parser = build_parser()
        args = parser.parse_args()
        run_server(args)
    else:
        # Only launches setup if no CLI args are shown
        launch_startup_options()

if __name__ == "__main__":
    main()
