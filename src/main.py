import argparse
import sys
import time
import os
import webbrowser

from backend.submodule_automation import gitPull
import backend.dbcs as dbcs
from backend.sockio.socket import socketio, app as socketio_app
from backend.db_connection import DbConnection
from backend.input import consumer, logfile_producer, live_log_producer, radio_producer
from functools import partial
from backend.sockio import debug_dashboard, alert_manager  # noqa: F401 (ensure handlers are registered)
from startup_server import launch_startup_options

SOCKETIO_PORT = 5500

def build_parser() -> argparse.ArgumentParser:
    data_sources = ["pastlog", "livelog", "mock_livelog", "db", "radio"]
    parser = argparse.ArgumentParser()
    parser.add_argument("logType", choices=data_sources, type=str.lower,
                        help="The type of data source to use.")
    parser.add_argument("--inputFile", "-i", type=str, nargs=1,
                        help="Path of input file (log/db) depending on mode.")
    parser.add_argument("--outputDB", "-o", type=str, nargs=1, default=None,
                        help="Output DB name (.db/.sqlite). Autogenerated if not specified.")
    parser.add_argument("--set_dbc_branch", "-b", type=str, default="main",
                        help="Branch of the DBC files submodule.")
    return parser

def run_server(args):
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    db_dir = './CANDatabases'
    if not os.path.exists(db_dir):
        os.makedirs(db_dir)

    submodule_path = os.path.relpath("resources/CAN-messages")
    success, message = gitPull(args.set_dbc_branch, submodule_path=submodule_path)
    print("[GIT]", message)
    if not success:
        print("[GIT ERROR] Continuing anyway...")

    dbcs.load_dbc_files()

    if getattr(args, "inputFile", None) and args.inputFile and not os.path.exists(args.inputFile[0]):
        print(f"The input file '{args.inputFile[0]}' does not exist.")
        sys.exit()

    datafile_path = args.inputFile[0] if args.inputFile else None

    database_path = f"./CANDatabases/can_database_{timestamp}.sqlite"
    if args.outputDB:
        database_path = args.outputDB[0]
    if not database_path.endswith(".db") and not database_path.endswith(".sqlite"):
        raise ValueError("Need to specify a .db or .sqlite file for the output database")

    if args.logType == "db":
        if not args.inputFile:
            raise ValueError("The '--inputFile' option is required when 'db' is provided.")
        if not (args.inputFile[0].endswith(".db") or args.inputFile[0].endswith(".sqlite")):
            raise ValueError("Need to specify a .db or .sqlite file")
        database_path = args.inputFile[0]

    DbConnection.setup_the_db_path(database_path)
    dbconn = DbConnection()
    dbconn.setup_the_tables()

    if args.logType == "pastlog":
        if not args.inputFile or not (args.inputFile[0].endswith(".txt") or args.inputFile[0].endswith(".log")):
            raise ValueError("For 'pastlog', need a .txt or .log file as --inputFile")
        logfile_producer.process_logfile(datafile_path)
        consumer.process_data()

    elif args.logType == "livelog":
        socketio.start_background_task(target=consumer.process_data_live)
        socketio.start_background_task(target=live_log_producer.listen_to_serial)

    elif args.logType == "mock_livelog":
        if not args.inputFile or not (args.inputFile[0].endswith(".txt") or args.inputFile[0].endswith(".log")):
            raise ValueError("For 'mock_livelog', need a .txt or .log file as --inputFile")
        socketio.start_background_task(target=consumer.process_data_live)
        socketio.start_background_task(target=partial(logfile_producer.process_logfile_live, datafile_path))

    elif args.logType == "radio":
        socketio.start_background_task(target=consumer.process_data_live)
        socketio.start_background_task(target=radio_producer.listen_to_radio)

    print(f"Starting socketio server, \033[1;31mopen localhost:{SOCKETIO_PORT} in your browser\033[0m")
    webbrowser.open(f'http://localhost:{SOCKETIO_PORT}')
    socketio.run(socketio_app, debug=False, allow_unsafe_werkzeug=True, host="0.0.0.0", port=SOCKETIO_PORT)

def main():
    # Continue supporting CLI args 
    if len(sys.argv) > 1:
        parser = build_parser()
        args = parser.parse_args()
        run_server(args)
    else:
        # Only launches setup if no CLI args are shown
        launch_startup_options(run_server)

if __name__ == "__main__":
    main()
