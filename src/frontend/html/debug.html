{% extends './generic.html' %}

{% block content %}
    <div>

        <div class="container-fluid mt-4">
            <div class="row">
                <!-- Left large container -->
                <div class="col-md-8">
                    <div class="large-container">
                        <div class="text-container" id="messageContainer">
                            <!-- Content for large container will be dynamically updated -->
                        </div>
                    </div>
                </div>

                <!-- Right smaller containers -->
                <div class="col-md-4">
                    <div class="small-container" id="checkbox-container" style="height:600px">
                        <div class="text-container">
                            <h5>Message Types</h5>
                            <input 
                                type="text" 
                                id="search-bar" 
                                class="form-control mb-3" 
                                placeholder="Search tables..." 
                                onkeyup="filterCheckboxes()"
                            />
                        </div>
                        <hr class="separator">
                    <div class="small-container mt-4" style="height:350px">
                        <div class="text-container">
                            <!-- Content for small container 3 -->
                            <form id="table-names-form">
                                <!-- Checkboxes for table names will be dynamically populated here -->
                            </form>
                        </div>
                    </div>
                </div>
                </div>
            </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
    <script>
// Socket connection to Flask app
// const socket = io('http://127.0.0.1:5000');
const maxMessagesPerTable = 1;

// Object to store messages for different tables
let checkedTables = ["MotorCommands", "DashboardCommands"]; //initial checked messages
let tableMessages = {};
let lastReceivedTime = {};
let lastMessageTime = {};

// Function to fetch table names and populate checkboxes
function fetchTableNames() {
    fetch('/get_table_names')
        .then(response => response.json())
        .then(data => {
            if (Array.isArray(data.table_names)) {
                populateCheckboxes(data.table_names, checkedTables);
            }
        })
        .catch(error => {
            console.error('Error fetching table names:', error);
        });
}

// Function to fetch the latest messages
function fetchLatestMessages() {
    fetch('/get_latest_message')
        .then(response => response.json())
        .then(batchData => {
            console.log('Received message batch:', batchData);
            batchData.messages.forEach((data) => {
                displayMessage(data, checkedTables);
            });
        })
        .catch(error => {
            console.error('Error fetching latest messages:', error);
        });
}
let startTime = Date.now();
fetchTableNames();
setInterval(fetchLatestMessages, 1000);
function populateCheckboxes(tableNames, defaultCheckedTables = []) {
    console.log("Starting populating...");
    const checkboxContainer = document.getElementById('table-names-form');
    checkboxContainer.innerHTML = '';
    checkedTables = [];

    for (let i = 0; i < tableNames.length; i++) {
    const tableName = tableNames[i];
    if (tableName === "sqlite_sequence" || tableName === "Alerts" || tableName === "TriggeredAlerts") {
        continue;
    }

    if (!document.getElementById('checkbox_' + tableName)) {
        const checkboxWrapper = document.createElement('div');
        checkboxWrapper.className = 'checkbox-wrapper';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.name = 'tableName';
        checkbox.value = tableName;
        checkbox.id = 'checkbox_' + tableName;

        checkbox.checked = defaultCheckedTables.includes(tableName);

        const label = document.createElement('label');
        label.htmlFor = checkbox.id;
        label.appendChild(document.createTextNode(tableName));

        checkboxWrapper.appendChild(checkbox);
        checkboxWrapper.appendChild(label);
        checkboxContainer.appendChild(checkboxWrapper);

        checkbox.addEventListener('change', loadTableData);
        if (checkbox.checked) {
            checkedTables.push(tableName);
            console.log("Table Name: " + tableName);
        }
    }
}

    const defaultCheckedCheckboxes = document.querySelectorAll(
        'input[name="tableName"]:checked'
    );
    defaultCheckedCheckboxes.forEach((checkbox) => {
        checkbox.dispatchEvent(new Event('change'));
    });
}
function loadTableData() {
    const form = document.getElementById('table-names-form');
    const checkedTables = [];

    form.querySelectorAll('input[name="tableName"]:checked').forEach((checkbox) => {
        checkedTables.push(checkbox.value);
    });
    if (checkedTables.length > 0) {
        updateVisibleTables(checkedTables);
    } else {
        updateVisibleTables(null);
    }
}
function updateVisibleTables(selectedTables) {
    const messageContainer = document.getElementById('messageContainer');
    const allCards = messageContainer.querySelectorAll('.card');

    allCards.forEach((card) => {
        const tableName = card.id.replace('card_', '');

        if (!selectedTables || selectedTables.includes(tableName)) {
            card.style.display = 'block';
        } else {
            card.style.display = 'none';
        }
    });
}
let hasInitializedVisibleTables = false;
let lastTimeStamp = {};

function displayMessage(data, checkedTables) {
    const messageContainer = document.getElementById('messageContainer');
    const tableName = data.table_name;
    const timestamp = data.timestamp;

    if (!lastReceivedTime[tableName] || lastTimeStamp[tableName] !== timestamp) {
        lastTimeStamp[tableName] = timestamp;
        lastReceivedTime[tableName] = Date.now();
    }
    if (!tableMessages[tableName]) {
        tableMessages[tableName] = [];
        
        const card = document.createElement('div');
        card.className = 'card mt-3';
        card.id = 'card_' + tableName;

        const cardHeader = document.createElement('div');
        cardHeader.className = 'card-header';
        cardHeader.innerText = tableName;

        const cardBody = document.createElement('div');
        cardBody.className = 'card-body';
        cardBody.id = 'cardBody_' + tableName;
        card.appendChild(cardHeader);
        card.appendChild(cardBody);
        messageContainer.appendChild(card);
    }
    tableMessages[tableName].push(data);
    if (tableMessages[tableName].length > maxMessagesPerTable) {
        tableMessages[tableName].shift();
    }
    const cardBody = document.getElementById('cardBody_' + tableName);
    cardBody.innerHTML = '';

    tableMessages[tableName].forEach((msg) => {
        const messageContent = [];
        for (const key in msg.data) {
            messageContent.push(`${key}: ${msg.data[key]}`);
        }
        const timeElapsedSpan = document.createElement('span');
        timeElapsedSpan.className = 'time-elapsed';
        timeElapsedSpan.dataset.table = tableName;
        if (data.timestamp !== lastTimeStamp[tableName]) {
            timeElapsedSpan.innerText = "Just now";
        } else {
            const secondsAgo = Math.floor((Date.now() - lastReceivedTime[tableName]) / 1000);
            if (secondsAgo < 60) {
                timeElapsedSpan.innerText = `${secondsAgo} seconds ago`;
            } else {
                const minutesAgo = Math.floor(secondsAgo / 60);
                timeElapsedSpan.innerText = `${minutesAgo} minutes ago`;
            }
        }

        const newMessageDiv = document.createElement('div');
        if (timestamp !== -1){
            newMessageDiv.appendChild(timeElapsedSpan);
            newMessageDiv.appendChild(document.createElement('br'));
        }
        if (timestamp === -1){
            messageContent.push("No Messages Received")
            newMessageDiv.appendChild(document.createTextNode(messageContent.join('\n')));
            newMessageDiv.classList.add('message', 'mb-2');
            cardBody.appendChild(newMessageDiv);
            return;
        }
        newMessageDiv.appendChild(document.createTextNode(messageContent.join('\n')));
        newMessageDiv.classList.add('message', 'mb-2');

        cardBody.appendChild(newMessageDiv);
    });
    new Sortable(messageContainer, {
                handle: '.card-header', // Enable dragging from the card header
                animation: 150,
                onStart(evt) {
                    evt.item.style.opacity = '0.5';
                },
                onEnd(evt) {
                    evt.item.style.opacity = '1';
                }
            });
    cardBody.scrollTop = cardBody.scrollHeight;
    loadTableData(checkedTables);
}

function updateElapsedTime() {
    const now = Date.now();
    document.querySelectorAll('.time-elapsed').forEach((element) => {
        const tableName = element.dataset.table;
        if (lastReceivedTime[tableName]) {
            const secondsAgo = Math.floor((now - lastReceivedTime[tableName]) / 1000);
            if (secondsAgo < 60) {
                element.innerText = `${secondsAgo} seconds ago`;
            } else {
                const minutesAgo = Math.floor(secondsAgo / 60);
                element.innerText = `${minutesAgo} minutes ago`;
            }
        }
    });
}

setInterval(updateElapsedTime, 1000);


function filterCheckboxes() {
    const searchInput = document.getElementById('search-bar').value.toLowerCase();
    const checkboxes = document.getElementById('table-names-form').querySelectorAll('input[type="checkbox"]');

    checkboxes.forEach((checkbox) => {
        const label = checkbox.nextElementSibling.textContent.toLowerCase();
        if (label.includes(searchInput)) {
            checkbox.parentElement.style.display = 'block';
        } else {
            checkbox.parentElement.style.display = 'none';
        }
    });
}
</script>
{% endblock %}
